# War3 Game StatString Decode 解码函数逆向分析 (Game.dll)

**地址**: `Game.dll + 0x650820` (War3 1.26a)
**功能**: `DecodeStatString`
**作用**: 将输入的编码过的 StatString（二进制流）通过位移和异或算法解密，并将结果写入到一个 `CBitStream` 对象中供后续解析使用。

## 1. 核心逻辑摘要

1.  **输入**: 指向 StatString 的指针。
2.  **解密算法**:
    *   遍历输入数据。
    *   **每 8 个字节** 为一组。
    *   每组的 **第 1 个字节** 是掩码/头部 (Mask)，不作为数据输出，仅用于更新滚动密钥 (Rolling Key)。
    *   每组的 **后 7 个字节** 是数据，与密钥进行 XOR 和位移运算还原明文。
3.  **终止条件**: 遇到 `0x00` 结束符。
4.  **安全检查**: 如果读取超过 128 (`0x80`) 字节仍未结束，则判定失败。
5.  **返回值**:
    *   `1` (True): 解码成功（在限制范围内遇到结束符）。
    *   `0` (False): 解码失败（缓冲区溢出）。

---

## 2. 反汇编详细注释

```assembly
; ========================================================================
; 函数入口: DecodeStatString
; ECX = CBitStream 对象指针 (输出目标)
; ESP+18 = StatString 原始数据指针 (输入源)
; ========================================================================
6F650820 | 51                       | push ecx                                                 |
6F650821 | 53                       | push ebx                                                 |
6F650822 | 55                       | push ebp                                                 |
6F650823 | 56                       | push esi                                                 |
6F650824 | 57                       | push edi                                                 |
6F650825 | 8BF9                     | mov edi,ecx                                              | EDI = CBitStream 对象
6F650827 | 8B07                     | mov eax,dword ptr ds:[edi]                               |
6F650829 | 8B50 1C                  | mov edx,dword ptr ds:[eax+1C]                            | 获取虚函数 (Reset/Init)
6F65082C | 33DB                     | xor ebx,ebx                                              | EBX = 输入索引 (Input Counter)
6F65082E | 33F6                     | xor esi,esi                                              | ESI = 输出计数 (Output Counter)
6F650830 | FFD2                     | call edx                                                 | 初始化 BitStream
6F650832 | 8B6C24 18                | mov ebp,dword ptr ss:[esp+18]                            | EBP = 输入数据指针
6F650836 | 32C9                     | xor cl,cl                                                | CL = 初始解密密钥 (Key) = 0
6F650838 | EB 0A                    | jmp game.6F650844                                        | -> 进入循环

; --- 循环重入点 ---
6F65083A | 8D9B 00000000            | lea ebx,dword ptr ds:[ebx]                               | (Padding)
6F650840 | 8A4C24 18                | mov cl,byte ptr ss:[esp+18]                              | 恢复密钥 CL

; ========================================================================
; 主解密循环
; ========================================================================
6F650844 | 8A042B                   | mov al,byte ptr ds:[ebx+ebp]                             | 读取输入字节 -> AL
6F650847 | 84C0                     | test al,al                                               | 检查是否为 0x00
6F650849 | 74 3F                    | je game.6F65088A                                         | -> 若为 0，成功结束

6F65084B | F6C3 07                  | test bl,7                                                | 检查 EBX % 8 (是否为每组的第1个字节)
6F65084E | 75 08                    | jne game.6F650858                                        | -> 不是第1字节，跳转到数据解密

; [分支 A] 掩码字节处理 (Mask Byte)
; 每8字节的第1字节仅用于更新密钥，不产生输出
6F650850 | D0E8                     | shr al,1                                                 | AL 右移 1 位
6F650852 | 884424 18                | mov byte ptr ss:[esp+18],al                              | 更新栈上的密钥 (CL)
6F650856 | EB 27                    | jmp game.6F65087F                                        | 跳过输出，处理下一个

; [分支 B] 数据字节解密 (Data Byte)
; 算法: Out = (In ^ Key) ^ ((In ^ Key) & 1)
6F650858 | 8AD0                     | mov dl,al                                                | DL = 当前字节
6F65085A | 32D1                     | xor dl,cl                                                | DL = DL XOR Key
6F65085C | 80E2 01                  | and dl,1                                                 | 取最低位
6F65085F | 32C2                     | xor al,dl                                                | AL = AL XOR DL
6F650861 | D0E9                     | shr cl,1                                                 | 密钥右移 (Rolling Key)

; --- 写入解密结果 ---
6F650863 | 83FE 68                  | cmp esi,68                                               | 检查 BitStream 是否已满 (104字节限制)
6F650866 | 884424 10                | mov byte ptr ss:[esp+10],al                              | 暂存结果
6F65086A | 884C24 18                | mov byte ptr ss:[esp+18],cl                              | 保存密钥
6F65086E | 73 2C                    | jae game.6F65089C                                        | -> 溢出则报错
6F650870 | 8B4424 10                | mov eax,dword ptr ss:[esp+10]                            |
6F650874 | 50                       | push eax                                                 |
6F650875 | 8BCF                     | mov ecx,edi                                              |
6F650877 | E8 E418E7FF              | call game.6F4C2160                                       | call BitStream::WriteBits() 写入数据
6F65087C | 83C6 01                  | add esi,1                                                | 输出计数 + 1

; --- 循环控制 ---
6F65087F | 83C3 01                  | add ebx,1                                                | 输入计数 + 1
6F650882 | 81FB 80000000            | cmp ebx,80                                               | 检查总长度是否超过 128 字节
6F650888 | 72 B6                    | jb game.6F650840                                         | -> 未超过，继续循环

; ========================================================================
; 成功退出 (Success Path)
; ========================================================================
6F65088A | 5F                       | pop edi                                                  |
6F65088B | 81FB 80000000            | cmp ebx,80                                               | 再次确认是否正常结束
6F650891 | 5E                       | pop esi                                                  |
6F650892 | 1BC0                     | sbb eax,eax                                              | EAX 设为 -1 (若 CF=1)
6F650894 | 5D                       | pop ebp                                                  |
6F650895 | F7D8                     | neg eax                                                  | EAX 取反 -> 1 (True)
6F650897 | 5B                       | pop ebx                                                  |
6F650898 | 59                       | pop ecx                                                  |
6F650899 | C2 0400                  | ret 4                                                    | 返回 1

; ========================================================================
; 失败退出 (Error Path)
; ========================================================================
6F65089C | 5F                       | pop edi                                                  |
6F65089D | 5E                       | pop esi                                                  |
6F65089E | 5D                       | pop ebp                                                  |
6F65089F | 33C0                     | xor eax,eax                                              | EAX = 0 (False)
6F6508A1 | 5B                       | pop ebx                                                  |
6F6508A2 | 59                       | pop ecx                                                  |
6F6508A3 | C2 0400                  | ret 4                                                    | 返回 0
```

---

## 3. 为什么 Bot 房间能通过此函数？

**现象**: Bot 发送了错误的 ASCII Hex 字符串 (`"99e3..."`)，但此函数返回了 `1` (成功)。

**原因解析**:
1.  **判定标准单一**: 此函数**只**关心一件事：输入流是否在 128 字节内以 `0x00` 结尾。
2.  **输入符合标准**: Bot 发送的字符串是一个合法的 C 字符串，确实以 `0x00` 结尾，且长度通常小于 128。
3.  **无内容校验**: 此函数**不校验**解密后的数据是否有意义。它只是机械地执行 XOR 运算。
    *   输入 `0x99` (Binary) -> 算法 -> 输出 `正确数据`。
    *   输入 `0x39` (ASCII) -> 算法 -> 输出 `乱码数据` (Garbage)。

**后果**:
虽然解码函数返回了“成功”，但 `CBitStream` (EDI) 里被填满了乱码。
导致上一层函数 (`6F654510`) 在解析这些乱码时，因数据长度/格式不匹配而报错 (`cmp` 指针校验失败)，最终导致**右侧面板空白**。